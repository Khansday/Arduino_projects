/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/7252d02d-11fd-4d74-9a52-bf0079e4ad32 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float air_Quality;
  float hmdt;
  float prss;
  float tmp;
  int ax;
  int ay;
  int az;
  int distance1;
  int distance2;
  int distance3;
  int distance4;
  int distance5;
  int gx;
  int gy;
  int gz;
  int pulse_Beat;
  CloudLocation location;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"   //library for IOT cloud
#include "Arduino.h"
#include "Arduino_BHY2Host.h"
#include "portenta_info.h"
#include "mbed.h"

#include <SPI.h>  //Library for SD Card
#include <SD.h>

const int chipSelect = 4; // Define the CS pin, change if needed
File dataFile;
int fileIndex = 1; // Start with the first file index
// NICLA BOARD VARIABLE SECTION
Sensor temp(SENSOR_ID_TEMP_WU);
Sensor humidity(SENSOR_ID_HUM);
Sensor pressure(SENSOR_ID_BARO);
Sensor gas(SENSOR_ID_GAS);
SensorXYZ gyroscope(SENSOR_ID_GYRO);
SensorXYZ accelerometer(SENSOR_ID_ACC);
SensorQuaternion quaternion(SENSOR_ID_RV);
SensorBSEC bsec(SENSOR_ID_BSEC);
int yled = LEDR;
int gled = LEDG;

// ULTRASOUND VARIABLES
#define NUM_SENSORS 5

const int sensorPins[NUM_SENSORS] = {3, 4, 5, 1, 2}; // Pins used for each sensor
const int maxDistance = 200; // Maximum distance in centimeters

float latitude=52.414509674919344, longitude=-1.8304553552694747;   //storing the location data
 

long unsigned int cloudUpdate,newFile,printTime;   //debugging purposes

void setup() {
  bootM4();     //enable second core
  // Defined in thingProperties.h
  initProperties();
  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  Serial.begin(460800);
  Serial1.begin(9600);
  pinMode(yled,OUTPUT);
  pinMode(gled,OUTPUT);
  digitalWrite(yled,LOW);    
  delay(10);
  for (int i = 0;i<10;i++){      //this visually indicates the start of the setup
      digitalWrite(yled,HIGH);
      delay(50);
      digitalWrite(yled,LOW);
      delay(50);
  }

  BHY2Host.begin();
  temp.begin();      
  humidity.begin();   
  pressure.begin();
  gyroscope.begin();
  accelerometer.begin();
  bsec.begin();
  gas.begin();

  delay(10);               //this visually indicates the end of the setup

  Serial.print("Initializing SD card...");

  if (!SD.begin(chipSelect)) {
    Serial.println("Initialization failed!");
    delay(10);               
  }
  Serial.println("Initialization done.");
  createNewFile();

  digitalWrite(gled,LOW);
  cloudUpdate = millis();
  newFile = millis();
}

void loop() {
  printTime = millis();
  if (millis() - cloudUpdate > 800){  //update cloud every 800 ms
    ArduinoCloud.update();    //BOTTLENECK OF ARDUINO CLOUD IS 1s !!!!!
    cloudUpdate = millis();  
  }

  BHY2Host.update();                  
  delay(2);                    //update cloud variables
  ax = accelerometer.x();
  ay = accelerometer.y();
  az = accelerometer.z();

  gx = gyroscope.x();
  gy = gyroscope.y();
  gz = gyroscope.z();

  tmp = temp.value() - 9;
  hmdt = humidity.value();
  prss = pressure.value();
  air_Quality = bsec.iaq();
  updateUltrasound();         //Read ultrasound and update cloud

  while (Serial1.available() > 0) {   //check for gps data
        String nmeaData = Serial1.readStringUntil('\n');
        // Check if the data is a GNGGA sentence
        if (nmeaData.startsWith("$GNGGA")) {
            parseGGA(nmeaData);
            location =  {latitude, longitude}; //update map location
        }
    }
  
  logData();
  Serial.println(millis()-printTime);  // use this too see the frequency of the loop

}

void updateUltrasound() {
  distance1 = readSensor(3);  //these are the pins where the sensors are connected to
  distance2 = readSensor(4);
  distance3 = readSensor(5);
  distance4 = readSensor(1);
  distance5 = readSensor(2);

}

int readSensor(int sensorPin) {
  // Trigger the sensor
  pinMode(sensorPin, OUTPUT);
  digitalWrite(sensorPin, LOW);
  delayMicroseconds(2);
  digitalWrite(sensorPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(sensorPin, LOW);

  // Switch pin to INPUT to read echo
  pinMode(sensorPin, INPUT);
  unsigned long echoTime = pulseIn(sensorPin, HIGH, 15000); // Maximum 50ms timeout
  int distance = echoTime / 29 / 2;

  return distance;
}

void parseGGA(String sentence) {  //GPS functions
    // Split the NMEA sentence into fields
    int commaIndex;
    int startIndex = 0;
    String fields[15];  // GGA has up to 15 fields

    for (int i = 0; i < 15; i++) {
        commaIndex = sentence.indexOf(',', startIndex);
        if (commaIndex == -1) {
            fields[i] = sentence.substring(startIndex);
            break;
        }
        fields[i] = sentence.substring(startIndex, commaIndex);
        startIndex = commaIndex + 1;
    }

    // Check if it's a GGA sentence and has enough fields
    if (fields[0] == "$GNGGA" && fields[2].length() >= 4 && fields[4].length() >= 5) {
        // Extract latitude and longitude
        latitude = fields[2].substring(0, 2).toDouble() + fields[2].substring(2).toDouble() / 60.0;
        if (fields[3] == "S") {
            latitude = -latitude;
        }
        longitude = fields[4].substring(0, 3).toDouble() + fields[4].substring(3).toDouble() / 60.0;
        if (fields[5] == "W") {
            longitude = -longitude;
        }
    }
}

void createNewFile() {
  if (dataFile) {
    dataFile.close();
  }

  while (true) {
    String fileName = "Data" + String(fileIndex) + ".txt";
    if (!SD.exists(fileName.c_str())) {
      dataFile = SD.open(fileName.c_str(), FILE_WRITE);
      if (dataFile) {
        Serial.print("Created new file: ");
        Serial.println(fileName);
        fileIndex++;
        break;
      } else {
        Serial.println("Error creating file");
      }
    } else {
      fileIndex++; // Increment the file index and try again
    }
  }
}

void logData() {
  if (millis() - newFile >= 30000) { // Every 30 seconds
    previousMillis = currentMillis;
    createNewFile();
  }

  if (dataFile) {
    dataFile.print("Ax: ");
    dataFile.print(ax);
    dataFile.print(" Ay: ");
    dataFile.print(ay);
    dataFile.print(" Az: ");
    dataFile.print(az);
    dataFile.print(" Gx: ");
    dataFile.print(gx);
    dataFile.print(" Gy: ");
    dataFile.print(gy);
    dataFile.print(" Gz: ");
    dataFile.print(gz);
    dataFile.print(" T: ");
    dataFile.print(tmp);
    dataFile.print(" H: ");
    dataFile.print(hmdt);
    dataFile.print(" P: ");
    dataFile.print(prss);
    dataFile.print(" Aq: ");
    dataFile.print(air_Quality);
    dataFile.print(" D1: ");
    dataFile.print(distance1);
    dataFile.print(" D2: ");
    dataFile.print(distance2);
    dataFile.print(" D3: ");
    dataFile.print(distance3);
    dataFile.print(" D4: ");
    dataFile.print(distance4);
    dataFile.print(" D5: ");
    dataFile.print(distance5);

    dataFile.println();

    Serial.println("Data written to file.");
    dataFile.flush(); // Ensure data is written to the SD card
  } else {
    Serial.println("Error writing to file");
  }
}

// IoT cloud variable change functions (add your code here if needed)
void onDistance1Change() {}
void onDistance2Change() {}
void onDistance3Change() {}
void onGyChange() {}
void onGxChange() {}
void onGzChange() {}
void onAxChange() {}
void onAyChange() {}
void onAzChange() {}
void onDistance4Change() {}
void onDistance5Change() {}
void onHumidityChange() {}
void onPressureChange() {}
void onTemperatureChange() {}
void onHmdtChange() {}
void onPrssChange() {}
void onTmpChange() {}
void onAirQualityChange() {}
void onPulseBeatChange()  {}
void onLocationChange()  {}

